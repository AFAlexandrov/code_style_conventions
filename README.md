# Конвенции кодирования

Этот документ описывает правила оформления кода, наиболее близкие моему субъективному восприятию.  

Из существующих конвенций наиболее комфортны для меня [Linux Kernel Coding Style](https://www.kernel.org/doc/html/latest/process/coding-style.html#codingstyle)
и доработанная на его основе [RIOT OS Coding Conventions](https://github.com/RIOT-OS/RIOT/blob/master/CODING_CONVENTIONS.md).

Однако, обе они избыточны для текущих задач.
Поэтому данный документ, в основном, состоит из экспортированных ключевых правил.  
Linux Kernel чётко и ёмко даёт обоснование ко всем объявленным там указаниям,
и потому обоснование логики многих тезисов / разделов дано по ссылкам на источник.  
Собственные дополнения / изменения располагаются отдельно и объясняются сразу под объявлением.

## [Основная информация](https://github.com/RIOT-OS/RIOT/blob/master/CODING_CONVENTIONS.md#general)

1. Основной стандарт языка - C99.
2. Оптимальная длина строки 80 символов. Допустимая - 100.
3. Если можно обойтись без динамического выделения памяти - стоит это сделать.

## [Отступы](https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation)

* Один таб - 8 символов.
* Метки case стоит выравнивать по ключевому слову switch.
* Не располагайте несколько выражений на одной строке, кроме ситуаций, когда необходимо что-то спрятать.
* Не допускайте множественного присваивания на одной строке.

* При объявлении констант препроцессором стоит использовать пробелы (например, при заполнении карты регистров)
	        Чтобы избежать проблем при просмотре на стороннем текстовый редакторе.

## [Разрыв строки](https://www.kernel.org/doc/html/latest/process/coding-style.html#breaking-long-lines-and-strings)

* Оптимальная длина строки 80 символов.  
	        Допустимая - 100.  
	        Экраны стали больше, однако наиболее эффективны, по прежнему, 80 символов,  
	        поскольку так можно уместить два-три файла на одном экране. Но, что важнее,  
	        это провоцирует лишний раз задумываться об уменьшении глубины вложенностей.
	
* Примеры разрыва строки:
* Посреди объявления функции (in progress, ниже варианты к обсуждению)

		/* (1) Продолжение на следующей строке с одним отступом */
		// При многочисленных объявлениях,
		// (1.1) в первом случае необходимо ставить пробелы между функциями,
		// (1.2) во втором - разделителем будет являться ");"
		/* (2) продолжение за скобкой */
		/* (3) продолжение на следующей строке с одним отступом */
		
		void irq_set_chip_and_handler_name (
			unsigned int irq,
			struct irq_chip * chip,
			irq_flow_handler_t handle,
			const char * name);

		void irq_set_chained_handler_and_data (
			unsigned int irq,
			irq_flow_handler_t handle,
			void * data
		);

		static inline bool dma_should_alloc_from_pool (struct device * dev, gfp_t gfp,
								unsigned long attrs);

		static struct page * __dma_direct_alloc_pages (struct device * dev, size_t size,
			gfp_t gfp, unsigned long attrs);

*Лично я предпочитаю (1.1) для объявлений и (1.2) для вызовов*

## [Расположение скобок и пробелов](https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces)

*Скобки*

* Во всех случаях фигурная скобка ставится в конце строки после пробела.
Кроме функций, когда скобка располагается в начале следующей строки.

* Закрывающая скобка всегда завершает строку, кроме случаев
	1. do-while
	2. if-else
	3. typdef struct / union / enum

*Пробелы*
* ставятся вокруг бинарных и тернарного операторов
* не ставятся между унарным оператором и его операндом
* не ставятся вокруг . и ->

## Объявления и вызовы
*Общие правила*


* специальные символы "(), [], \*" отделяются от ключевых слов и идентификаторов пробелом
	Паттерны текста, разделённые пробелом, читаются быстрее и легче,
	чем длинные неразрывные выражения.
* скобки ставятся вплотную ко внутреннему содержимому
* после запятой всегда пробел (но не до запятой!)

*Символы () и []*

При объявлении, скобки не выполняют функцию унарного оператора,
поэтому можно использовать пробел, для отделения от имени функции / массива.

		void action (void);

		uint8_t
			input_buffer [IN_BUF_SIZE] = {0},
			output_buffer [OUT_BUF_SIZE] = {0};


*Символ \**

Указатель при объявлении относится к идентификатору, а не к типу, во всех случаях, кроме объявления формальных параметров функции.
	
	/*То есть можно объявить так:*/
		type_t
			* func_1 (void),
			* func_2 (void),
			* var_ptr;

	/*Однако, очевидно, нельзя так:*/
		void func (type_t
			* var1,
			* var2,
			var3);

Поэтому, чтобы читалось быстрее, предлагается ставить пробелы вокруг * при объявлении.
Однако, поскольку чаще * относится к идентификатору, это правило в разработке.

*Несколько идентификаторов пишутся через запятую с переносом строки и одним отступом*

			char
				name_1 = '\0',
				name_2 = '\0';
			int
				num_1 = 0,
				num_2 = 0;

## Именование

* [Имена переменных и функций](https://www.kernel.org/doc/html/latest/process/coding-style.html#naming) в нижнем регистре.
* Слова в любом имени разделяются нижним подчёркиванием.
* [Имена макросов](#MACRO)

## [Синонимы типов](https://github.com/RIOT-OS/RIOT/blob/master/CODING_CONVENTIONS.md#types)

Синоним типов оканчиваются суффиксом \_t

		typedef void (* action_t) (void);

		typedef struct struct_name {
			char
				status : 3,
				buf [BUF_SIZE];
			struct struct_name * next; 
		} struct_name_t;

## [Функции](https://www.kernel.org/doc/html/latest/process/coding-style.html#functions)

* Не более 5-7 входных параметров
* Имена параметров в объявлении должны быть указаны
* В исходном тексте определения должны быть разделены пустой строкой

* Функции открытого интерфейса начинаются с имени блока, интерфейсом которого являются:
		
		dbase_record_t * parser_command_dbase (void);

* Функции закрытого интерфейса начинаются с нижнего подчёркивания
если реализованы в том же файле, что и функции открытого интерфейса

		void _push_byte (ring_t * ring, uint8_t byte);

* Например, нет необходимости начинать с подчёркивания функции, находящиеся в файлах \*\_internal.{c,h}

		char * extract_pattern (
			char * message,
			uint16_t from_here,
			uint16_t cmd_len
		);
		

## [Централизованный выход из функции](https://www.kernel.org/doc/html/latest/process/coding-style.html#centralized-exiting-of-functions)

*Предлагается использовать goto с выразительно именованными метками для*

* совершения однотипной работы при выходе из функции
* сокращения количества уровней вложенности
* предотвращения частых модификаций отдельных точек выхода

## Комментарии

* [Комментарии более, чем в одну строку](https://www.kernel.org/doc/html/latest/process/coding-style.html#commenting).

* Для однострочных заметок стоит использовать

		/* One line comment */

* Для отладочных комментариев, которые будут удалены

		init_something(
			first_param_variant_1,
			// first_param_variant_2,
			second_param
		);

## <a name = "MACRO">Макросы</a>
* Все константы состоят из символов верхнего регистра

		#define SOME_CONST_VAL 5

* Если константа содержит вычисляемое выражение, требуются скобки

		#define MIN_IN_HOUR    (60 * 60)

* Если необходим перенос строки, он размещается на расстоянии одного пробела от конца строки.
* При этом внешние обрамляющие скобки оформляются как указано ниже, чтобы не перегружать само выражение:

		#define SOME_LONG_CONST_DEFINITION ( \
			(SOME_CONST_VAL + 7) / 3.1415926 \
		)

* Макросы, оборачивающие действие начинаются с большой буквы, ";" в конце строки не ставится

*Макросы с параметрами*

* Каждый параметр в скобках

		#define Ring_push_message(ring, source, len) \
			(ring)->push_message((ring), (source), (len))
			
		#define Power_of_two(power) pow(2, (power))

* Даже, если нет параметров, в конце ставятся круглые скобки на манер вызова функции, чтобы подчеркнуть что это действие.

		#define Reset_some_value() some_value = 0

*Макросы, содержащие объявление / инициализацию*

		#define Make_list(list_name, ... /* items */) \
			static items_type_t list_name [] = { \
				__VA_ARGS__, list_terminator \
			}

		#define __watchdog_register() \
        		int8_t wdog_id = sys_watchdog_register(false)

## [Возвращаемые значения](https://www.kernel.org/doc/html/latest/process/coding-style.html#function-return-values-and-names) функций

* Если имя функции - *действие или команда*, она должна возвращать *целочисленный код ошибки*.
* Если имя функции - *предикат*, она должна возвращать *булевый статус*.

## Встраивание inline-функции (in progress ...)
## Встраивание ассемблера (in progress ...)

## Условная компиляция

Везде, где возможно, [не стоит](https://www.kernel.org/doc/html/latest/process/coding-style.html#conditional-compilation) использовать условные конструкции препроцессора в .c файлах.
Это делает код менее читаемым и усложняет понимание логики. Вместо этого стоит выполнить все преобразования в
заголовочном файле, где в ветке #else будет располагаться заглушка, которую компилятор проигнорирует при сборке.
Таким образом в .c файле можно будет вызвать функцию без предусловий.

*Пример*

		#if dg_configUSE_WDOG
		#	define __watchdog_register() \
		        	int8_t wdog_id = sys_watchdog_register(false)
		#else
		#	define __watchdog_register()
		#endif

Предпочтительнее компилировать целые функции, а не их части.
(Вместо того, чтобы помещать ifdef в выражение, стоит вынести это выражение в функцию и применить условие к функции целиком.)

*Уровни вложенности оформляются следующим образом*
		
		#define A
		#define E
		#ifdef A
		#	define B
		#else
		#	define C
		#	if defined E
		# 		define X
		#	endif
		#endif

#### Примеры и прочее

Если необходим булевый тип следует использовать стандартный (С99) \_Bool, вместо bool.  
И значения true / false, вместо 0 / 1.

Если необходимо обнулить пременную при инициализации:

	символам предпочтительнее присваивать '\0',
	указателям - NULL,
	целым числам - 0,
	числам с плавающей точкой - 0.0,
	составным типам - {0} (
		в этом случае стоит помнить, что в С99 это обнулит
		все элементы / поля ТОЛЬКО при инициализации,
		присваивание таким образом обнулит только нулевой элемент
	),
	булевой переменной - false

*Cтруктуры, объединения, перечисления*
 
  		struct parser_record { 
			char			   
				* command,
				* response
				* parameter;
			void (* action) (void);
			struct parser_record * subcommand;
		};

Применение операторов

Унарные ставятся вплотную к операнду

		if (!entity) return NULL;
		
		uint32_t
			* ptr = &some_var; // & near "some_var" identifier
			val = *ptr; // * near "ptr" identifier
			
		char
			str [] = "string",
			sym = str[0]; // [] near "str" identifier
		
		

Вокруг бинарных ставятся пробелы 

		if (parser_command_dbase() == NULL) // spaces around the "==" operator
			return parser_empty_cmd_dbase();

Для тернарного оператора при использовании " : " ставятся пробелы по обе стороны, а последний операнд записывается на новой строке

		parser_set_action(command->action ? // здесь спорный момент, иногда лучше записать как на примере ниже
			command->action :
			parser_stub_action()
		);
		
		parser_set_action(
			command->action ? // вот таким образом. Аргументы в пользу того или иного случая в разработке
			command->action :
			parser_stub_action()
		);
		
		// Первый случай стоит использовать, если первый аргумент функции - дескриптор сущности / экземпляр "класса".

Таблица сравнений на тернарном операторе

		result =
			(a == b) ? 1 :
			(a == c) ? 2 :
			(a == d) ? 3 :
		0;

*Побитовые операторы*

Согласно правилам оформления для унарных и бинарных операторов:

		uint8_t zeros_in_mask &= ~msk;

---
## Блоки и библиотеки

Под библиотекой понимаем связку двух и более файлов с расширениями .c и .h
Подключённых линейно, то есть:

header_1.h ---> sourse_1.c
header_2.h --/

либо

header_1.h ---> header_2.h ---> source_1.c

Под блоком понимаем две пары файлов file.c и file.h  c явно разделёнными открытым и закрытым интерфейсами
При этом объявления строго в заголовках (иногда кроме inline)
А реализации строго в file.c

TODO // оформит через plantUML
1. варианты связи блоков

1.1. через открытые интерфейсы

1.2. через закрытые

1.3. кольцом

---

## Тесты

Процесс разработки алгоритмических блоков построен по методологии TDD.
Для тестирования используется unity фрэймворк от ThrowTheSwitch.
Тесты хранятся и собираются отдельно от кода.
Для генерации структуры проекта на основе идеологии блоков используется [скрипт](https://github.com/AFAlexandrov/tdd_creator)
