# Конвенции кодирования


**1. Основная информация**

**2. Блоки и библиотеки**
      
**3. Тесты**

**4. Правила оформления кода**
	
    4.1 Объявления,инициализация
    
    4.2 Типы данных
      * Базовые
      * Производные
      * Пользовательские

    4.3 Применение операторов

--------


## **1.Основная информация**

Попытка систематизировать самые основные правила, применяемые в практике повседневного кодирования.

---
## **2.Блоки и библиотеки**

Под библиотекой понимаем связку двух и более файлов с расширениями .c и .h
Подключённых линейно, то есть:

header_1.h ---> sourse_1.c
header_2.h --/

либо

header_1.h ---> header_2.h ---> source_1.c

Под блоком понимаем две пары файлов file.c и file.h  c явно разделёнными открытым и закрытым интерфейсами
При этом объявления строго в заголовках (иногда кроме inline)
А реализации строго в file.c

TODO // оформит через plantUML
1. варианты связи блоков

1.1. через открытые интерфейсы

1.2. через закрытые

1.3. кольцом

---
## **3.Тесты**

Процесс разработки построен по методологии TDD.
Для тестирования используется unity фрэймворк от ThrowTheSwitch.
Тесты хранятся отдельно от кода.
Для генерации структуры проекта на основе идеологии блоков используется скрипт *ссылку сюда*

---


## **4. Правила оформления кода**

Оптимальная длина строки 80 - 90 символов

#### ОБЪЯВЛЕНИЕ, ИНИЦИАЛИЗАЦИЯ

*Общие правила для объявлений*

	* специальные символы "*, [], ()," отделяются от ключевых слов и идентификаторов пробелом
	* знаки препинания по аналогии с английским языком
	* скобки ставятся вплотную ко внутреннему содержимому
	* если необходимо *продолжить* на новой строке - ставится один отступ после переноса
	* если необходимо *завершить* на новой строке - завершающий символ ставится на уровне начала выражения

###### **Препроцессор**

*Все константы состоят из символов верхнего регистра, слова разделяются нижним подчёркиванием*

		#define SOME_CONST_VAL 5

*Длинные константные выражения (переносятся на следующую строку)*

*Если длина #define + ИМЯ_КОНСТАНТЫ + её описание >= оптимальной длины - добавляется перенос строки*
*При наличии скобок внутри выражения, внешние обрамляющие скобки оформляются как указано ниже, чтобы не перегружать само выражение:*

		#define SOME_LONG_CONST_DEFINITION ( \
			(SOME_CONST_VAL + 7) / 3.1415926 \
		)
		
*Макросы, оборачивающие действие начинаются с большой буквы, слова разделяются нижними подчёркиваниями. ";" в конце строки не ставится*

*Если нет параметров, в конце ставятся круглые скобки на манер вызова функции, чтобы подчеркнуть что это действие.*

		#define Reset_some_value() some_value = 0

*Макросы, содержащие объявление/инициализацию*

		#define Make_list(list_name, ... /* items */) \
			static items_type_t list_name [] = { \
				__VA_ARGS__, list_terminator \
			}

*Макросы с параметрами*

*Каждый параметр обязательно в скобках*

		#define Ring_push_message(ring, source, len) \
			(ring)->push_message((ring), (source), (len))
			
		#define Power_of_two(power) pow(2, (power))

*Условная компиляция (в разработке...)*

*Уровни вложенности оформляются следующим образом*
		
		#define A
		#define E
		#ifdef A
		#	define B
		#else
		#	define C
		#	if defined E
		# 		define X
		#	endif
		#endif

#### ТИПЫ ДАННЫХ

*Если необходимо обнулить при инициализации, символам предпочтительнее присваивать '\0', указателям - NULL, целым числам - 0, числам с плавающей точкой - 0.0*

###### **Базовые**

*Один идентификатор*

			char name = '\0';

*Несколько идентификаторов пишутся через запятую с переносом строки и одним отступом*

			char
				name_1 = '\0',
				name_2 = '\0';
			int
				num_1 = 0,
				num_2 = 0;`

###### **Производные** 

*Массивы*

Один идентификатор

			char string [STRING_SIZE] = {'\0'};	
			
*Несколько идентификаторов пишутся через запятую с переносом строки и одним отступом*

			uint8_t
				input_buffer [IN_BUF_SIZE] = {0},
				output_buffer [OUT_BUF_SIZE] = {0};`

*Указатели (пробелы с обеих сторон от "*"), по одному пробелу с каждой стороны*

Один идентификатор

			uint32_t * ptr = NULL;
			long long double *** surface_matrix = NULL;

Несколько идентификаторов

			uint16_t
				* window = NULL,
				coef_table = NULL;
				
Пример объявления указателя на функцию

	void (* action) (void);

Пример объявления массива указателей на функции

	void (* arr_of_func_ptrs [SIZE]) (double parameter);

*Функции*
 
 Функции закрытого интерфейса начинаются с нижнего подчёркивания (кроме тех, что находятся в файлах *_internal.{c,h})
		
		void _push_byte (ring_t * ring, uint8_t byte);
		
 Функции открытого интерфейса начинаются с имени блока, интерфейсом которого являются:
		
		dbase_record_t * parser_command_dbase (void);
	

		char * extract_pattern (
			char * message,
			uint16_t from_here,
			uint16_t cmd_len
		);
		

###### **Пользовательские**

*Cтруктуры, объединения, перечисления*
 
  		struct parser_record { 
			char			   
				* command,
				* response
				* parameter;
			void (* action) (void);
			struct parser_record * subcommand;
		};

###### **Синонимы**

Синоним типов оканчиваются суффиксом _t

		typedef void (* action_t) (void);

		typedef struct struct_name {
			char
				status : 3,
				buf [BUF_SIZE];
			struct struct_name * next; 
		} struct_name_t;

Применение операторов

Унарные ставятся вплотную к операнду

		if (!entity) return NULL;
		
		uint32_t
			* ptr = &some_var; // & near "some_var" identifier
			val = *ptr; // * near "ptr" identifier
			
		char
			str [] = "string",
			sym = str[0]; // [] near "str" identifier
		
		

Вокруг бинарных ставятся пробелы 

		if (parser_command_dbase() == NULL) // spaces around the "==" operator
			return parser_empty_cmd_dbase();

Для тернарного оператора при использовании " : " ставятся пробелы по обе стороны, а последний операнд записывается на новой строке

		parser_set_action(command->action ? // здесь спорный момент, иногда лучше записать как на примере ниже
			command->action :
			parser_stub_action()
		);
		
		parser_set_action(
			command->action ? // вот таким образом. Аргументы в пользу того или иного случая в разработке
			command->action :
			parser_stub_action()
		);

Таблица сравнений на тернарном операторе

		result =
			(a == b) ? 1 :
			(a == c) ? 2 :
			(a == d) ? 3 :
		0;

*Побитовые операторы*

Согласно правилам оформления для унарных и бинарных операторов:

		uint8_t zeros_in_mask &= ~msk;

*Операторы работы с указателями и членами классов*
			
При использовании операторов доступа к членами структуры пробелы не ставятся... естественно

		parser_set_action(
			command->action ?
			command->action :
			parser_stub_action()
		);
		
		ring.push_byte(ring, byte);



